<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-instant-objects">
  <h1>Temporal.Instant Objects</h1>
  <p>A Temporal.Instant object is an immutable Object referencing a point in time with nanoseconds precision.</p>

  <emu-clause id="sec-temporal-instant-constructor">
    <h1>The Temporal.Instant Constructor</h1>
    <p>
      The Temporal.Instant constructor is the %Temporal.Instant% intrinsic object.
      When called as a constructor, it creates and initializes a new Temporal.Instant object.
    </p>
    <p>
      The Temporal.Instant constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified Instant behaviour must include a super call to the %Temporal.Instant% constructor to create and initialize subclass instances with the necessary internal slots.
    </p>

    <emu-clause id="sec-temporal.instant">
      <h1>Temporal.Instant ( _epochNanoseconds_ )</h1>
      <p>
        When the `Temporal.Instant` function is called, the following steps are taken:
      </p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _epochNanoseconds_ be ? ToBigInt(_epochNanoseconds_).
        1. Perform ? RejectInstant(_epochNanoseconds_).
        1. Return ? CreateTemporalInstant(_epochNanoseconds_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-instant-constructor">
    <h1>Properties of the Temporal.Instant Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.Instant constructor is the intrinsic object %Function.prototype%.</p>
    <p>The Temporal.Instant constructor has the following properties:</p>

    <emu-clause id="sec-temporal-instant-prototype">
      <h1>Temporal.Instant.prototype</h1>
      <p>The initial value of `Temporal.Instant.prototype` is %Temporal.Instant.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant-@@species">
      <h1>get Temporal.Instant [ @@species ]</h1>
      <p>
        `Temporal.Instant[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.from">
      <h1>Temporal.Instant.from ( _item_ )</h1>
      <p>
        The `from` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _constructor_ be the *this* value.
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalInstant]] internal slot, then
          1. Return ? CreateTemporalInstantFromStatic(_constructor_, _item_.[[Nanoseconds]]).
        1. Return ? ToTemporalInstant(_item_, _constructor_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochseconds">
      <h1>Temporal.Instant.fromEpochSeconds ( _epochSeconds_ )</h1>
      <p>
        The `fromEpochSeconds` method takes one argument _epochSeconds_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _epochSeconds_ to ? ToNumber(_epochSeconds_).
        1. Set _epochSeconds_ to ? NumberToBigInt(_epochSeconds_).
        1. Let _epochNanoseconds_ be _epochSeconds_ √ó 1,000,000,000.
        1. Perform ? RejectInstant(_epochNanoseconds_).
        1. Let _constructor_ be the *this* value.
        1. Return ? CreateTemporalInstantFromStatic(_constructor_, _epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochmilliseconds">
      <h1>Temporal.Instant.fromEpochMilliseconds ( _epochMilliseconds_ )</h1>
      <p>
        The `fromEpochMilliseconds` method takes one argument _epochMilliseconds_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _epochMilliseconds_ to ? ToNumber(_epochMilliseconds_).
        1. Set _epochMilliseconds_ to ? NumberToBigInt(_epochMilliseconds_).
        1. Let _epochNanoseconds_ be _epochMilliseconds_ √ó 1,000,000.
        1. Perform ? RejectInstant(_epochNanoseconds_).
        1. Let _constructor_ be the *this* value.
        1. Return ? CreateTemporalInstantFromStatic(_constructor_, _epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochmicroseconds">
      <h1>Temporal.Instant.fromEpochMicroseconds ( _epochMicroseconds_ )</h1>
      <p>
        The `fromEpochMicroseconds` method takes one argument _epochMicroseconds_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _epochMicroseconds_ to ? ToBigInt(_epochMicroseconds_).
        1. Let _epochNanoseconds_ be _epochMicroseconds_ √ó 1,000.
        1. Perform ? RejectInstant(_epochNanoseconds_).
        1. Let _constructor_ be the *this* value.
        1. Return ? CreateTemporalInstantFromStatic(_constructor_, _epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.fromepochnanoseconds">
      <h1>Temporal.Instant.fromEpochNanoseconds ( _epochNanoseconds_ )</h1>
      <p>
        The `fromEpochNanoseconds` method takes one argument _epochNanoseconds_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _epochNanoseconds_ to ? ToBigInt(_epochNanoseconds_).
        1. Perform ? RejectInstant(_epochNanoseconds_).
        1. Let _constructor_ be the *this* value.
        1. Return ? CreateTemporalInstantFromStatic(_constructor_, _epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.compare">
      <h1>Temporal.Instant.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Set _one_ to ? ToTemporalInstant(_one_).
        1. Set _two_ to ? ToTemporalInstant(_two_).
        1. Return ùîΩ(! CompareEpochNanoseconds(_one_.[[Nanoseconds]], _two_.[[Nanoseconds]])).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-instant-prototype-object">
    <h1>Properties of the Temporal.Instant Prototype Object</h1>

    <p>The Temporal.Instant prototype object</p>
    <ul>
      <li>is the intrinsic object <dfn>%Temporal.Instant.prototype%</dfn>.
      <li>is itself an ordinary object.
      <li>is not a Temporal.Instant instance and does not have a [[InitializedTemporalInstant]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id="sec-temporal.instant.prototype.constructor">
      <h1>Temporal.Instant.prototype.constructor</h1>
      <p>The initial value of `Temporal.Instant.prototype.constructor` is %Temporal.Instant%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype-@@tostringtag">
      <h1>Temporal.Instant.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value `"Temporal.Instant"`.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochseconds">
      <h1>get Temporal.Instant.prototype.epochSeconds</h1>
      <p>
        `Temporal.Instant.prototype.epochSeconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Let _s_ be RoundTowardsZero(‚Ñù(_ns_) / 1,000,000,000<sub>‚Ñù</sub>).
        1. Return ùîΩ(_s_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochmilliseconds">
      <h1>get Temporal.Instant.prototype.epochMilliseconds</h1>
      <p>
        `Temporal.Instant.prototype.epochMilliseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Let _ms_ be RoundTowardsZero(‚Ñù(_ns_) / 1,000,000<sub>‚Ñù</sub>).
        1. Return ùîΩ(_ms_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochmicroseconds">
      <h1>get Temporal.Instant.prototype.epochMicroseconds</h1>
      <p>
        `Temporal.Instant.prototype.epochMicroseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Let _¬µs_ be RoundTowardsZero(‚Ñù(_ns_) / 1,000<sub>‚Ñù</sub>).
        1. Return ‚Ñ§(_¬µs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.instant.prototype.epochnanoseconds">
      <h1>get Temporal.Instant.prototype.epochNanoseconds</h1>
      <p>
        `Temporal.Instant.prototype.epochNanoseconds` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _ns_ be _instant_.[[Nanoseconds]].
        1. Return _ns_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.add">
      <h1>Temporal.Instant.prototype.add ( _temporalDurationLike_ )</h1>
      <p>
        The `add` method takes one argument _temporalDurationLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _ns_ be ! AddInstant(_instant_.[[EpochNanoseconds]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Return ? CreateTemporalInstantFromInstance(_instant_, _ns_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.subtract">
      <h1>Temporal.Instant.prototype.subtract ( _temporalDurationLike_ )</h1>
      <p>
        The `subtract` method takes one argument _temporalDurationLike_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª).
        1. Perform ? RejectDurationSign(_duration_.[[Years]], _duration_.[[Months]], _duration_.[[Weeks]], _duration_.[[Days]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _ns_ be ! AddInstant(_instant_.[[EpochNanoseconds]], ‚àí_duration_.[[Hours]], ‚àí_duration_.[[Minutes]], ‚àí_duration_.[[Seconds]], ‚àí_duration_.[[Milliseconds]], ‚àí_duration_.[[Microseconds]], ‚àí_duration_.[[Nanoseconds]]).
        1. Return ? CreateTemporalInstantFromInstance(_instant_, _ns_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.until">
      <h1>Temporal.Instant.prototype.until ( _other_ [ , _options_ ] )</h1>
      <p>
        The `until` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _other_ to ? ToTemporalInstant(_other_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, *"nanoseconds"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalDurationUnits(*"seconds"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be the mathematical value of ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _roundedNs_ be ? DifferenceInstant(_instant_.[[Nanoseconds]], _other_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Let _result_ be ! BalanceDuration(0, 0, 0, 0, 0, 0, _roundedNs_, _largestUnit_).
        1. Return ? CreateTemporalDuration(0, 0, 0, 0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.since">
      <h1>Temporal.Instant.prototype.since ( _other_ [ , _options_ ] )</h1>
      <p>
        The `since` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _other_ to ? ToTemporalInstant(_other_).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalDurationUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, *"nanoseconds"*).
        1. Let _defaultLargestUnit_ be ! LargerOfTwoTemporalDurationUnits(*"seconds"*, _smallestUnit_).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, ¬´ *"years"*, *"months"*, *"weeks"*, *"days"* ¬ª, _defaultLargestUnit_).
        1. Perform ? ValidateTemporalUnitRange(_largestUnit_, _smallestUnit_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. Let _maximum_ be ! MaximumTemporalDurationRoundingIncrement(_smallestUnit_).
        1. Let _roundingIncrement_ be the mathematical value of ? ToTemporalRoundingIncrement(_options_, _maximum_, *false*).
        1. Let _roundedNs_ be ? DifferenceInstant(_other_.[[Nanoseconds]], _instant_.[[Nanoseconds]], _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Let _result_ be ! BalanceDuration(0, 0, 0, 0, 0, 0, _roundedNs_, _largestUnit_).
        1. Return ? CreateTemporalDuration(0, 0, 0, 0, _result_.[[Hours]], _result_.[[Minutes]], _result_.[[Seconds]], _result_.[[Milliseconds]], _result_.[[Microseconds]], _result_.[[Nanoseconds]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.round">
      <h1>Temporal.Instant.prototype.round ( _options_ )</h1>
      <p>
        The `round` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _smallestUnit_ be ? ToSmallestTemporalUnit(_options_, ¬´ *"day"* ¬ª).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"nearest"*).
        1. If _smallestUnit_ is *"hour"*, then
          1. Let _maximum_ be 24.
        1. Else if _smallestUnit_ is *"minute"*, then
          1. Let _maximum_ be 1440.
        1. Else if _smallestUnit_ is *"second"*, then
          1. Let _maximum_ be 86400.
        1. Else if _smallestUnit_ is *"millisecond"*, then
          1. Let _maximum_ be 8.64 √ó 10<sup>7</sup>.
        1. Else if _smallestUnit_ is *"microsecond"*, then
          1. Let _maximum_ be 8.64 √ó 10<sup>10</sup>.
        1. Else,
          1. Assert: _smallestUnit_ is *"nanosecond"*.
          1. Let _maximum_ be 8.64 √ó 10<sup>13</sup>.
        1. Let _roundingIncrement_ be the mathematical value of ? ToTemporalRoundingIncrement(_options_, _maximum_, *true*).
        1. Let _ns_ be the mathematical value of _instant_.[[Nanoseconds]].
        1. Let _roundedNs_ be ? RoundTemporalInstant(_ns_, _roundingIncrement_, _smallestUnit_, _roundingMode_).
        1. Return ? CreateTemporalInstantFromInstance(_instant_, _roundedNs_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.equals">
      <h1>Temporal.Instant.prototype.equals ( _other_ )</h1>
      <p>
        The `equals` method takes one argument _other_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _other_ to ? ToTemporalInstant(_other_).
        1. If _instant_.[[Nanoseconds]] ‚â† _other_.[[Nanoseconds]], return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tostring">
      <h1>Temporal.Instant.prototype.toString ( [ _options_ ] )</h1>
      <p>
        The `toString` method takes one argument _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Set _options_ to ? NormalizeOptionsObject(_options_).
        1. Let _timeZone_ be ? Get(_options_, *"timeZone"*).
        1. If _timeZone_ is not *undefined*, then
          1. Set _timeZone_ to ? ToTemporalTimeZone(_timeZone_).
        1. Let _precision_ be ? ToSecondsStringPrecision(_options_).
        1. Let _roundingMode_ be ? ToTemporalRoundingMode(_options_, *"trunc"*).
        1. Let _ns_ be the mathematical value of _instant_.[[Nanoseconds]].
        1. Let _roundedNs_ be ? RoundTemporalInstant(_ns_, _precision_.[[Increment]], _precision_.[[Unit]], _roundingMode_).
        1. Let _roundedInstant_ be ? CreateTemporalInstant(_roundedNs_).
        1. Return ? TemporalInstantToString(_roundedInstant_, _timeZone_, _precision_.[[Precision]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tolocalestring">
      <h1>Temporal.Instant.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ? TemporalInstantToString(_instant_, *undefined*, *"auto"*).
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return ? FormatDateTime(_dateFormat_, _instant_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tojson">
      <h1>Temporal.Instant.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Return ? TemporalInstantToString(_instant_, *undefined*, *"auto"*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.valueof">
      <h1>Temporal.Instant.prototype.valueOf ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tozoneddatetime">
      <h1>Temporal.Instant.prototype.toZonedDateTime ( _item_ )</h1>
      <p>
        The `toZonedDateTime` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. If Type(_item_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _calendarLike_ be ? Get(_item_, *"calendar"*).
        1. If _calendarLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _calendar_ be ? ToTemporalCalendar(_calendarLike_).
        1. Let _temporalTimeZoneLike_ be ? Get(_item_, *"timeZone"*).
        1. If _temporalTimeZoneLike_ is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _timeZone_ be ? ToTemporalTimeZone(_temporalTimeZoneLike_).
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.instant.prototype.tozoneddatetimeiso">
      <h1>Temporal.Instant.prototype.toZonedDateTimeISO ( _item_ )</h1>
      <p>
        The `toZonedDateTimeISO` method takes one argument _item_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. If Type(_item_) is Object, then
          1. Let _timeZoneProperty_ be ? Get(_item_, *"timeZone"*).
          1. If _timeZoneProperty_ is not *undefined*, then
            1. Set _item_ to _timeZoneProperty_.
        1. Let _timeZone_ be ? ToTemporalTimeZone(_item_).
        1. Let _calendar_ be ? GetISO8601Calendar().
        1. Return ? CreateTemporalZonedDateTime(_instant_.[[Nanoseconds]], _timeZone_, _calendar_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-temporal-instant-instances">
    <h1>Properties of Temporal.Instant Instances</h1>

    <p>
      Temporal.Instant instances are ordinary objects that inherit properties from the %Temporal.Instant.prototype% intrinsic object.
      Temporal.Instant instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-temporalinstant-instances"></emu-xref>.
    </p>
    <emu-table id="table-internal-slots-of-temporalinstant-instances" caption="Internal Slots of Temporal.Instant Instances">
      <table>
        <tbody>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[InitializedTemporalInstant]]
            </td>
            <td>
              The only specified use of this slot is for distinguishing Temporal.Instant instances from other objects.
            </td>
          </tr>
          <tr>
            <td>
              [[Nanoseconds]]
            </td>
            <td>
              A BigInt value representing the number of nanoseconds since the Unix epoch.
            </td>
          </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-temporal-instant-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-validateinstant" aoid="ValidateInstant">
      <h1>ValidateInstant ( _ns_ )</h1>
      <emu-alg>
        1. Assert: Type(_ns_) is BigInt.
        1. If _ns_ &lt; ‚àí8.64 √ó 10<sup>21</sup><sub>‚Ñù</sub> or _ns_ &gt; 8.64 √ó 10<sup>21</sup><sub>‚Ñù</sub>, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-rejectinstant" aoid="RejectInstant">
      <h1>RejectInstant ( _ns_ )</h1>
      <emu-alg>
        1. Assert: Type(_ns_) is BigInt.
        1. If ! ValidateInstant(_ns_) is *false*, then
          1. Throw a *RangeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalinstant" aoid="CreateTemporalInstant">
      <h1>CreateTemporalInstant ( _ns_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: Type(_ns_) is BigInt.
        1. Assert: ! ValidateInstant(_ns_) is *true*.
        1. If _newTarget_ is not given, set it to %Temporal.Instant%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.Instant.prototype%"`, ¬´ [[InitializedTemporalInstant]], [[Nanoseconds]] ¬ª).
        1. Set _object_.[[Nanoseconds]] to _ns_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalinstantfromstatic" aoid="CreateTemporalInstantFromStatic">
      <h1>CreateTemporalInstantFromStatic ( _constructor_, _ns_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateInstant(_ns_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, ¬´ _ns_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalInstant]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporalinstantfrominstance" aoid="CreateTemporalInstantFromInstance">
      <h1>CreateTemporalInstantFromInstance ( _instant_, _ns_ )</h1>
      <emu-alg>
        1. Assert: Type(_instant_) is Object and _instant_ has an [[InitializedTemporalInstant]] internal slot.
        1. Assert: ! ValidateInstant(_ns_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_instant_, %Temporal.Instant%).
        1. Let _result_ be ? Construct(_constructor_, ¬´ _ns_ ¬ª).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalInstant]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporalinstant" aoid="ToTemporalInstant">
      <h1>ToTemporalInstant ( _item_ [ , _constructor_ ] )</h1>
      <p>
        The abstract operation ToTemporalInstant returns its argument _item_ if it is already a Temporal.Instant instance, converts _item_ to a new Temporal.Instant instance if possible, and throws otherwise.
      </p>
      <emu-alg>
        1. If _constructor_ is not given, set it to %Temporal.Instant%.
        1. If Type(_item_) is Object and _item_ has an [[InitializedTemporalInstant]] internal slot, then
          1. Return _item_.
        1. Let _string_ be ? ToString(_item_).
        1. Let _epochNanoseconds_ be ? ParseTemporalInstant(_string_).
        1. Return ? CreateTemporalInstantFromStatic(_constructor_, _epochNanoseconds_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-parsetemporalinstant" aoid="ParseTemporalInstant">
      <h1>ParseTemporalInstant ( _isoString_ )</h1>
      <emu-alg>
        1. Assert: Type(_isoString_) is String.
        1. Let _result_ be ? ParseTemporalInstantString(_isoString_).
        1. Let _offsetString_ be _result_.[[TimeZoneOffsetString]].
        1. If _offsetString_ is *undefined*, then
          1. Throw a *RangeError* exception.
        1. Let _utc_ be ? GetEpochFromParts(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
        1. If _utc_ &lt; ‚àí8.64 √ó 10<sup>21</sup><sub>‚Ñù</sub> or _utc_ &gt; 8.64 √ó 10<sup>21</sup><sub>‚Ñù</sub>, then
          1. Throw a *RangeError* exception.
        1. Let _offsetNanoseconds_ be ? ParseTimeZoneOffsetString(_offsetString_).
        1. Return _utc_ ‚àí _offsetNanoseconds_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-compareepochnanoseconds" aoid="CompareEpochNanoseconds">
      <h1>CompareEpochNanoseconds ( _epochNanosecondsOne_, _epochNanosecondsTwo_ )</h1>
      <emu-alg>
        1. If _epochNanosecondsOne_ &gt; _epochNanosecondsTwo_, return 1.
        1. If _epochNanosecondsOne_ &lt; _epochNanosecondsTwo_, return -1.
        1. Return 0.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-addinstant" aoid="AddInstant">
      <h1>AddInstant ( _epochNanoseconds_, _hours_, _minutes_, _seconds_, _milliseconds_, _microseconds_, _nanoseconds_ )</h1>
      <p>
        The abstract operation AddInstant adds a duration in various time units to a number of nanoseconds since the Unix epoch.
      </p>
      <emu-alg>
        1. Let _result_ be _epochNanoseconds_ + _nanoseconds_ +
            _microseconds_ √ó 1000 +
            _milliseconds_ √ó 1,000,000 +
            _seconds_ √ó 1,000,000,000 +
            _minutes_ √ó 60,000,000,000 +
            _hours_ √ó 3,600,000,000,000.
        1. Perform ? RejectInstant(_result_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-differenceinstant" aoid="DifferenceInstant">
      <h1>DifferenceInstant ( _ns1_, _ns2_, _roundingIncrement_, _smallestUnit_, _roundingMode_ )</h1>
      <p>
        The abstract operation DifferenceInstant computes the difference between two exact times expressed in nanoseconds since the Unix epoch, and rounds the result according to the given parameters.
      </p>
      <emu-alg>
        1. If _smallestUnit_ is *"hours"*, then
          1. Let _incrementNs_ be _roundingIncrement_ √ó 3.6 √ó 10<sup>12</sup>.
        1. If _smallestUnit_ is *"minutes"*, then
          1. Let _incrementNs_ be _roundingIncrement_ √ó 6 √ó 10<sup>10</sup>.
        1. Else if _smallestUnit_ is *"seconds"*, then
          1. Let _incrementNs_ be _roundingIncrement_ √ó 10<sup>9</sup>.
        1. Else if _smallestUnit_ is *"milliseconds"*, then
          1. Let _incrementNs_ be _roundingIncrement_ √ó 10<sup>6</sup>.
        1. Else if _smallestUnit_ is *"microseconds"*, then
          1. Let _incrementNs_ be _roundingIncrement_ √ó 10<sup>3</sup>.
        1. Else,
          1. Assert: _smallestUnit_ is *"nanoseconds"*.
          1. Let _incrementNs_ be _roundingIncrement_.
        1. Let _diff_ be _ns2_ ‚àí _ns1_.
        1. Return ? RoundNumberToIncrement(_diff_, _incrementNs_, _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-roundtemporalinstant" aoid="RoundTemporalInstant">
      <h1>RoundTemporalInstant ( _ns_, _increment_, _unit_, _roundingMode_ )</h1>
      <p>
        The abstract operation RoundTemporalInstant rounds a number of nanoseconds since the Unix epoch to the given rounding increment.
      </p>
      <emu-alg>
        1. If _unit_ is *"hour"*, then
          1. Let _incrementNs_ be _increment_ √ó 3.6 √ó 10<sup>12</sup>.
        1. Else if _unit_ is *"minute"*, then
          1. Let _incrementNs_ be _increment_ √ó 6 √ó 10<sup>10</sup>.
        1. Else if _unit_ is *"second"*, then
          1. Let _incrementNs_ be _increment_ √ó 10<sup>9</sup>.
        1. Else if _unit_ is *"millisecond"*, then
          1. Let _incrementNs_ be _increment_ √ó 10<sup>6</sup>.
        1. Else if _unit_ is *"microsecond"*, then
          1. Let _incrementNs_ be _increment_ √ó 10<sup>3</sup>.
        1. Else,
          1. Let _incrementNs_ be _increment_.
        1. Return ? RoundNumberToIncrement(_ns_, _incrementNs_, _roundingMode_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporalinstanttostring" aoid="TemporalInstantToString">
      <h1>TemporalInstantToString ( _instant_, _timeZone_, _precision_ )</h1>
      <emu-alg>
        1. Assert: Type(_instant_) is Object.
        1. Assert: _instant_ has an [[InitializedTemporalInstant]] internal slot.
        1. Let _outputTimeZone_ be _timeZone_.
        1. If _outputTimeZone_ is *undefined*, then
          1. Set _outputTimeZone_ to ? CreateTemporalTimeZone(*"UTC"*).
        1. Let _isoCalendar_ be ? GetISO8601Calendar().
        1. Let _dateTime_ be ? GetTemporalDateTimeFor(_timeZone_, _instant_, _isoCalendar_).
        1. Let _dateTimeString_ be ? TemporalDateTimeToString(_dateTime_.[[ISOYear]], _dateTime_.[[ISOMonth]], _dateTime_.[[ISODay]], _dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], *undefined*, _precision_, *"never"*).
        1. If _timeZone_ is *undefined*, then
          1. Let _timeZoneString_ be *"Z"*.
        1. Else,
          1. Let _timeZoneString_ be ? GetOffsetStringFor(_timeZone_, _instant_).
        1. Return the string-concatenation of _dateTimeString_ and _timeZoneString_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
